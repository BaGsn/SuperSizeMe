<!doctype html>
<html lang="">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
		<title>Editor</title>
		<link rel="stylesheet" href="dist/reset.css" type="text/css" />
		<!--media="screen"-->
		<link rel="stylesheet" href="dist/print.css" type="text/css" media="print" />
		<style>
			.myDIV {
			    width: 100%;
			    height: 20vh;
			    font-size:20vh;
			    display: -webkit-flex; /* Safari */
			    display: -ms-flex; /* Edge */
			    display: flex;
			    text-transform: uppercase;
			}

			.myDIV:first-child{
				margin-top: 15px;
			}
			
			#test{
				position: absolute;
				-webkit-shape-outside: circle(50%);
    			shape-outside: circle(50%);
				left:20%;
				top:20%;
				width:200px;
				height:200px;
				overflow: hidden;
			}

				
			}
		</style>
		<script>
		var fontBook = {
			urlMini: './fonts/0_narrow.otf',
			urlMiddle: './fonts/middle.otf',
			urlMaxi: './fonts/1_extended.otf',
			staticFontValue:Â []
		}

		
		/*
		var x=0;
		var y=1;
		var rList=[];
		var rt=document.getElementsByClassName('rt');
		var random=Math.random()*(y*(1-x));
		for(var i=0;i<rt.length-1;i++){
			var random=Math.random()*(y*(1-x));
			rList.push(random);
			rt.style.flex=random;
			console.log(random);
		}*/
		</script>
	</head>
	<body>

	<div id="test">In programming languages, a type system is a collection of rules that assign a property called type to various constructs a computer program consists of, such as variables, expressions, functions or modules.[1] The main purpose of a type system is to reduce possibilities for bugs in computer programs[2] by defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of static and dynamic checking. Type systems have other purposes as well, such as enabling certain compiler optimizations, allowing for multiple dispatch, providing a form of documentation, etc.
	
	A type system associates a type with each computed value and, by examining the flow of these values, attempts to ensure or prove that no type errors can occur. The particular type system in question determines exactly what constitutes a type error, but in general the aim is to prevent operations expecting a certain kind of value from being used with values for which that operation does not make sense (logic errors); memory errors will also be prevented. Type systems are often specified as part of programming languages, and built into the interpreters and compilers for them; although the type system of a language can be extended by optional tools that perform additional kinds of checks using the language's original type syntax and grammar.</div>

	<div class="workspace myDIV">
		<span class="rt">Super</span>
		<span class="rt">Size</span>
		<span class="rt">Me</span>
	</div>

	<div class="workspace myDIV">
		<span class="rt">Interpolate</span>
		<span class="rt">This</span>
		<span class="rt">Font</span>
	</div>

	<div class="workspace myDIV">
		<span class="rt">Dynamic</span>
		<span class="rt">Type</span>
		<span class="rt">Programm</span>
	</div>

	<div class="workspace myDIV">
		<span class="rt">If</span>
		<span class="rt">it</span>
		<span class="rt">fit</span>
	</div>

	<div class="workspace myDIV">
		<span class="rt">Then</span>
		<span class="rt">Please</span>
		<span class="rt" >Sit</span>
	</div>












		<canvas id="hidden-canvas" width="1024" height="1024" hidden />
		<script src="dist/plumin.js"></script>
		<script src="dist/supersizeme.js"></script>
		<script id="workerscript" type="text/workerscript">
		var otFont,
			otFont0,
			otFont1,
			font,
			font0,
			font1,
			coefx;
			coefy=0;
		
		// importScripts doesn't work with inline worker.
		// The following placeholder will be replaced with plumin source.
		// You wouldn't use inline workers and this trick in prod, though.
		PLUMINSOURCE
		
		plumin.paper.install(this);
		plumin.paper.setup({
			width: 1024,
			height: 1024
		});
		
		// Overwrite addToFonts to send the buffer over to the UI
		plumin.paper.Font.prototype.addToFonts = function(id) {
			var buffer = this.ot.toArrayBuffer();
			postMessage( {
				buf:buffer,
				id: id
			}, [buffer] );
		};
		
		onmessage = function( message ) {
			var data = message.data;
			switch ( Object.prototype.toString.call(data) ) {
			// parse incoming .otf ArrayBuffers
			case '[object Object]':
				if ( Object.keys(data)[0] === "lig"){
					if ( !data.lig || data.lig.constructor !== ArrayBuffer ) {
						return;
					}
			
					otFont = plumin.opentype.parse( data.lig );
					otFont0 = plumin.opentype.parse( data.lig );
					otFont1 = plumin.opentype.parse( data.hea );
			
					//console.log(plumin.opentype.parse( data.lig ));
					//console.log(plumin.opentype.parse( data.lig ));
			
					font = new plumin.paper.Font();
					// save default encoding
					var encoding = font.ot.encoding;
					font.importOT( otFont );
					font.ot.familyName = 'font';
					font.ot.encoding = encoding;
			
					font0 = new plumin.paper.Font();
					font0.importOT( otFont0 );
					font0.ot.familyName = 'font0';
			
					font1 = new plumin.paper.Font();
					font1.importOT( otFont1 );
					font1.ot.familyName = 'font1';
					break;
				}else if ( Object.keys(data)[0] === "x" && data.x!="undefined"){
					if (font) {
						for(var i=0;i<Object.keys(data)[0].length;i++){
							coefx=data.x[i];
							coefy=data.y[i];
							font.interpolate(font0, font1, coefx, coefy);
							font.updateOTCommands();
							font.addToFonts(i);
						}
				
					}
				
					break;
				}
		
			// parse incoming subset
			case '[object String]':
				// TODO: optimize to only interpolate new glyphs added to the subset
				if (font) {
					font.subset = data;
					font.interpolate(font0, font1, coefx, coefy);
					font.updateOTCommands();
					font.addToFonts();
				}
				break;

			// parse incoming interpolation coef
			case '[object Array]':
				if (font) {
					data.forEach(function(coefx, i) {
						font.interpolate(font0, font1, coefx, coefx);
						font.updateOTCommands();
						font.addToFonts(i);
					})
			
				}
			
				break;
			}
		};
	</script>
	</body>
</html>
